{
  "language": "Solidity",
  "sources": {
    "contracts/ProductValidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract ProductValidation {\r\n    uint256 public currentIndustryId;\r\n    uint256 public currentProductId;\r\n\r\n    address payable trustedParty; // the trusted party who will add the industry\r\n    address[] public industryAddress; // industry address to track the address inserted by trusted party\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║          Structs            ║\r\n      ╚═════════════════════════════╝*/\r\n    struct Product {\r\n        uint256 foodId; //should be a uniqueID\r\n        string productExpiurationDate; // given by farmer\r\n        string nameOfOwner; // given by farmer\r\n        uint256 productAmount;\r\n        uint256 currentProductId; // will receive the value from uint256 public currentProductId for tracking\r\n        address addedBy;\r\n    }\r\n\r\n    struct Industry {\r\n        uint256 insdustryId; //should be a uniqueID\r\n        string insdustryName;\r\n        uint256 insdustryID; // will receive the value from uint256 public currentIndustryId for tracking\r\n        address payable industryWalletAddress; // the wallet addresses who can call the storeProductInfo function\r\n\r\n        // you can store more info if needed\r\n    }\r\n\r\n    mapping(address => Industry) public industry; // store structs of Industry in a mapping\r\n    mapping(uint256 => Product) public productInfo; // store structs of product in a mapping\r\n\r\n    constructor(\r\n        address payable _trustedParty,\r\n        uint256 _currentIndustryId,\r\n        uint256 _currentProductId\r\n    ) {\r\n        trustedParty = _trustedParty;\r\n        currentIndustryId = _currentIndustryId;\r\n        currentProductId = _currentProductId;\r\n    }\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║           EVENTS            ║\r\n      ╚═════════════════════════════╝*/\r\n    event productAdded(\r\n        uint256 foodID,\r\n        string productExpiurationDate,\r\n        string nameOfOwner,\r\n        uint256 productAmount,\r\n        uint256 currentProductId,\r\n        address addedBy\r\n    );\r\n\r\n    event industryAdded(\r\n        uint256 insdustryId,\r\n        string insdustryName,\r\n        uint256 insdustryID,\r\n        address payable industryWalletAddress\r\n    );\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║      Helper Functions       ║\r\n      ╚═════════════════════════════╝*/\r\n    function _getTrustedParty(address _trustedParty)\r\n        internal\r\n        view\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            _trustedParty == trustedParty,\r\n            \"You are not permitted to call this function :D\"\r\n        );\r\n        if (_trustedParty == trustedParty) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _getIndustries(address _industryWalletAddress)\r\n        internal\r\n        view\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            industry[_industryWalletAddress].industryWalletAddress ==\r\n                _industryWalletAddress,\r\n            \"You are not permitted to call this function :D\"\r\n        );\r\n        if (\r\n            industry[_industryWalletAddress].industryWalletAddress ==\r\n            _industryWalletAddress\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @function _isWalletAddress\r\n     * @functiondesc - this will return true is the wallet given wallet address is valid otherwise it will return false\r\n     * @requires _walletAddress\r\n     */\r\n    function _isWalletAddress(address _walletAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_walletAddress)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║         Modifiers           ║\r\n      ╚═════════════════════════════╝*/\r\n    modifier isTrustedParty() {\r\n        require(\r\n            trustedParty == msg.sender,\r\n            \"You are not the truest party. Better try next time :D\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isTrustedPartyWalletValid(address _trustedParty) {\r\n        require(\r\n            !_isWalletAddress(_trustedParty),\r\n            \"Trusted party wallet address is not valid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isIndustryWalletValid(address _industryWalletAddress) {\r\n        require(\r\n            !_isWalletAddress(_industryWalletAddress),\r\n            \"Trusted party wallet address is not valid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*╔══════════════════════════════╗\r\n      ║       Create Industry        ║\r\n      ╚══════════════════════════════╝*/\r\n\r\n    /*****************************************************************\r\n     *  create industry list who will be allowed to add product info  *\r\n     *****************************************************************/\r\n    function createindustry(\r\n        uint256 _insdustryId,\r\n        string memory _insdustryName,\r\n        address payable _trustedParty,\r\n        address payable _industryWalletAddress\r\n    )\r\n        public\r\n        payable\r\n        // this trustedParty will be the one who deployed the contract\r\n        isTrustedParty\r\n        isTrustedPartyWalletValid(_trustedParty)\r\n        isIndustryWalletValid(_industryWalletAddress)\r\n        returns (string memory)\r\n    {\r\n        // check if the truestParty wallet address and industryWalletAddress are not same\r\n        require(\r\n            _trustedParty != _industryWalletAddress,\r\n            \"Trusted party address and industry wallet address cannot be same\"\r\n        );\r\n\r\n        // check if the trusted party address is the msg.sender or not\r\n        require(\r\n            _getTrustedParty(_trustedParty),\r\n            \"You are not allowed to add any industry\"\r\n        );\r\n\r\n        // check if the industry is already exists in the list or not\r\n        require(\r\n            industry[_industryWalletAddress].industryWalletAddress !=\r\n                _industryWalletAddress,\r\n            \"This industry is already exists in the list\"\r\n        );\r\n\r\n        currentIndustryId += 1;\r\n        industry[_industryWalletAddress].insdustryId = _insdustryId;\r\n        industry[_industryWalletAddress].insdustryName = _insdustryName;\r\n        industry[_industryWalletAddress].insdustryID = currentIndustryId;\r\n        industry[_industryWalletAddress]\r\n            .industryWalletAddress = _industryWalletAddress;\r\n        industryAddress.push(_industryWalletAddress);\r\n\r\n        // industryAdded event call to notify all nodes in the blockchain\r\n        emit industryAdded(\r\n            _insdustryId,\r\n            _insdustryName,\r\n            currentIndustryId,\r\n            _industryWalletAddress\r\n        );\r\n\r\n        return \"Industry successfully added in Blockchain. Cheers !!\";\r\n    }\r\n\r\n    /*╔══════════════════════════════╗\r\n      ║        Store Product         ║\r\n      ╚══════════════════════════════╝*/\r\n\r\n    /***********************************************\r\n     *  to store product information in blockchain  *\r\n     **********************************************/\r\n    function storeProductInfo(\r\n        uint256 _foodId,\r\n        string memory _productExpiurationDate,\r\n        string memory _nameOfOwner,\r\n        uint256 _productAmount,\r\n        address payable _industryWalletAddress\r\n    )\r\n        public\r\n        payable\r\n        isIndustryWalletValid(_industryWalletAddress)\r\n        returns (string memory)\r\n    {\r\n        // to check that the validated industry is calling this function or not\r\n        require(\r\n            _getIndustries(msg.sender),\r\n            \"You don't have access to add product\"\r\n        );\r\n\r\n        currentProductId += 1;\r\n        productInfo[_foodId].nameOfOwner = _nameOfOwner;\r\n        productInfo[_foodId].foodId = _foodId;\r\n        productInfo[_foodId].productAmount = _productAmount;\r\n        productInfo[_foodId].productExpiurationDate = _productExpiurationDate;\r\n        productInfo[_foodId].currentProductId = currentProductId;\r\n        productInfo[_foodId].addedBy = msg.sender;\r\n\r\n        // productAdded event call to notify all nodes in the blockchain\r\n        emit productAdded(\r\n            _foodId,\r\n            _productExpiurationDate,\r\n            _nameOfOwner,\r\n            _productAmount,\r\n            currentProductId,\r\n            msg.sender\r\n        );\r\n\r\n        return \"Successfully added the product information in Blockchain. Cheers !!\";\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}