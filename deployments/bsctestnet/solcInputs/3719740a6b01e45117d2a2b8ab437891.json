{
  "language": "Solidity",
  "sources": {
    "contracts/ProductValidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ncontract ProductValidation {\r\n    uint256 public currentIndustryId;\r\n    uint256 public currentProductId;\r\n\r\n    address payable trustedParty; // the trusted party who will add the industries\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║          Structs            ║\r\n      ╚═════════════════════════════╝*/\r\n    struct product {\r\n        uint256 foodId; //should be a uniqueID\r\n        string productExpiurationDate; // given by farmer\r\n        string nameOfOwner; // given by farmer\r\n        uint256 productAmount;\r\n        uint256 currentProductId; // will receive the value from uint256 public currentProductId for tracking\r\n        address addedBy;\r\n    }\r\n\r\n    struct Industry {\r\n        uint256 insdustryId; //should be a uniqueID\r\n        string insdustryName;\r\n        uint256 insdustryID; // will receive the value from uint256 public currentIndustryId for tracking\r\n        address payable industryWalletAddress; // the wallet addresses who can call the storeProductInfo function\r\n\r\n        // you can store more info if needed\r\n    }\r\n\r\n    Industry[] public industries; // array of industries\r\n    mapping(uint256 => product) public productInfo;\r\n\r\n    constructor(\r\n        address payable _trustedParty,\r\n        uint256 _currentIndustryId,\r\n        uint256 _currentProductId\r\n    ) {\r\n        trustedParty = _trustedParty;\r\n        currentIndustryId = _currentIndustryId;\r\n        currentProductId = _currentProductId;\r\n    }\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║           EVENTS            ║\r\n      ╚═════════════════════════════╝*/\r\n    event productAdded(\r\n        uint256 foodID,\r\n        string productExpiurationDate,\r\n        string nameOfOwner,\r\n        uint256 productAmount,\r\n        uint256 currentProductId,\r\n        address addedBy\r\n    );\r\n\r\n    event industryAdded(\r\n        uint256 insdustryId,\r\n        string insdustryName,\r\n        uint256 insdustryID,\r\n        address payable industryWalletAddress\r\n    );\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║       Helper Function       ║\r\n      ╚═════════════════════════════╝*/\r\n    function _getTrustedParty(address _trustedParty)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (_trustedParty == trustedParty) return true;\r\n        else return false;\r\n    }\r\n\r\n    /*\r\n     * @function _isWalletAddress\r\n     * @functiondesc - this will return true is the wallet given wallet address is valid otherwise it will return false\r\n     * @requires _walletAddress\r\n     */\r\n    function _isWalletAddress(address _walletAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_walletAddress)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n\r\n    /*╔═════════════════════════════╗\r\n      ║         Modifiers           ║\r\n      ╚═════════════════════════════╝*/\r\n    modifier isTrustedParty() {\r\n        require(\r\n            trustedParty == msg.sender,\r\n            \"You are not the truest party. Better try next time :D\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isTrustedPartyWalletValid(address _trustedParty) {\r\n        require(\r\n            !_isWalletAddress(_trustedParty),\r\n            \"Trusted party wallet address is not valid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isIndustryWalletValid(address _industryWalletAddress) {\r\n        require(\r\n            !_isWalletAddress(_industryWalletAddress),\r\n            \"Trusted party wallet address is not valid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*╔══════════════════════════════╗\r\n      ║       Create Industry        ║\r\n      ╚══════════════════════════════╝*/\r\n\r\n    /*****************************************************************\r\n     *  create industry list who will be allowed to add product info  *\r\n     *****************************************************************/\r\n    function createIndustries(\r\n        uint256 _insdustryId,\r\n        string memory _insdustryName,\r\n        address payable _trustedParty,\r\n        address payable _industryWalletAddress\r\n    )\r\n        public\r\n        payable\r\n        // this trustedParty will be the one who deployed the contract\r\n        isTrustedParty\r\n        isTrustedPartyWalletValid(_trustedParty)\r\n        isIndustryWalletValid(_industryWalletAddress)\r\n    {\r\n        if (\r\n            // check if the truestParty wallet address and industryWalletAddress are not same\r\n            _trustedParty != _industryWalletAddress\r\n        ) {\r\n            if (\r\n                // check if the trusted party address is the msg.sender or not\r\n                _getTrustedParty(_trustedParty)\r\n            ) {\r\n                currentIndustryId += 1;\r\n                industries.push(\r\n                    Industry({\r\n                        insdustryId: _insdustryId,\r\n                        insdustryName: _insdustryName,\r\n                        insdustryID: currentIndustryId, // at first iteration currentIndustryId will be 1+\r\n                        industryWalletAddress: _industryWalletAddress\r\n                    })\r\n                );\r\n\r\n                // industryAdded event call to notify all nodes in the blockchain\r\n                emit industryAdded(\r\n                    _insdustryId,\r\n                    _insdustryName,\r\n                    currentIndustryId,\r\n                    _industryWalletAddress\r\n                );\r\n            } else {\r\n                revert(\"You are not allowed to add industries\");\r\n            }\r\n        } else {\r\n            revert(\r\n                \"Trusted party address and industries wallet address cannot be same\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /*╔══════════════════════════════╗\r\n      ║        Store Product         ║\r\n      ╚══════════════════════════════╝*/\r\n\r\n    /***********************************************\r\n     *  to store product information in blockchain  *\r\n     **********************************************/\r\n    function storeProductInfo(\r\n        uint256 _foodId,\r\n        string memory _productExpiurationDate,\r\n        string memory _nameOfOwner,\r\n        uint256 _productAmount,\r\n        address payable _industryWalletAddress\r\n    ) public payable isIndustryWalletValid(_industryWalletAddress) {\r\n        // to check that the validated industry is calling this function or not\r\n        for (uint256 i = 0; i < industries.length; i += 1) {\r\n            if (\r\n                // check if the wallet address match with the validated industries wallet address\r\n                industries[i].industryWalletAddress == msg.sender &&\r\n                industries[i].industryWalletAddress == _industryWalletAddress\r\n            ) {\r\n                currentProductId += 1;\r\n                productInfo[_foodId].nameOfOwner = _nameOfOwner;\r\n                productInfo[_foodId].foodId = _foodId;\r\n                productInfo[_foodId].productAmount = _productAmount;\r\n                productInfo[_foodId]\r\n                    .productExpiurationDate = _productExpiurationDate;\r\n                productInfo[_foodId].currentProductId = currentProductId;\r\n                productInfo[_foodId].addedBy = msg.sender;\r\n\r\n                emit productAdded(\r\n                    _foodId,\r\n                    _productExpiurationDate,\r\n                    _nameOfOwner,\r\n                    _productAmount,\r\n                    currentProductId,\r\n                    msg.sender\r\n                );\r\n            } else {\r\n                // No Industry found with this ID and Name\r\n                revert(\"You are not permitted to add product info\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}